{"ast":null,"code":"// Require NPM modules in Node AND Meteor style!\nvar https = typeof Meteor === 'undefined' ? require('https') : Npm.require('https');\nvar endOfLine = (typeof Meteor === 'undefined' ? require('os') : Npm.require('os')).EOL;\nvar instance = false; // Holds the singleton instance\n\n// Wrapper for singleton\ngooglefonts = function (apiKey, options) {\n  instance = instance || new singleton(apiKey, options);\n  return instance;\n};\n\n// To prevent concurrent requests to the Google API we make use of a singleton.\n// There will only be one instance which handled concurrent requests internally.\nvar singleton = function (apiKey, options) {\n  self = this;\n  self.options = options || {};\n  self.apiKey = apiKey; // Holds the API key, may it be browser or server\n\n  self._buffer; // Buffer for API response\n  self._cache = false; // Cache for API response\n  self._lastFetch = false; // Timestamp when data was last fetched from googleapis.com\n  self.requestInProgress = false; // Will be true when API is currently queried\n\n  // Holds all callbacks to fire when API response completes. So why is this an\n  // array? Becuase we prevent concurrent requests. In case a fetch is called\n  // while alredy an API reqeusts is running, we simply collect the callbacks\n  // and fire them all together when the first reqeusts has finished.\n  self.callbacks = [];\n\n  // If nothing else specified, we cache API results for 1 hour\n  self.options.cacheLifeTime = self.options.cacheLifeTime || 3600;\n\n  // Fetch API result, save it to buffer + cache and call given callbacks\n  self.fetch = function (callback) {\n    // Check if we serve from cache or request the API\n    var now = new Date() / 1000;\n    if (self._cache && now - self._lastFetch < self.options.cacheLifeTime) {\n      callback(undefined, self._cache);\n      return self;\n    }\n\n    // If a new callback was given, add it to the list of callbacks\n    if (typeof callback === \"function\") {\n      self.callbacks.push(callback);\n    }\n\n    // If there already is a requests running, just return. The callback will be\n    // called later\n    if (self.requestInProgress === true) {\n      return self;\n    }\n    self.requestInProgress = true;\n    var options = {\n      host: 'www.googleapis.com',\n      path: '/webfonts/v1/webfonts?key=' + self.apiKey\n    };\n    self._buffer = \"\";\n    var request = https.request(options, function (result) {\n      result.setEncoding('utf8');\n\n      // Writing incoming chunks to internal buffer\n      result.on('data', function (chunk) {\n        self._buffer += chunk;\n      });\n\n      // Parse buffer into object, save into cache and call all callbacks\n      result.on('end', function () {\n        var parsed = JSON.parse(self._buffer);\n\n        // Google returned an error\n        if (typeof parsed.error != \"undefined\") {\n          var errorBuffer = options.host + \" returned errors:\";\n          parsed.error.errors.forEach(function (error) {\n            errorBuffer += endOfLine + \"  \" + error.message + \": \" + error.reason;\n          });\n          var error = new Error(errorBuffer);\n        }\n        self._lastFetch = new Date() / 1000;\n        self._cache = parsed;\n        self.requestInProgress = false;\n\n        //We have callbacks to fire\n        if (self.callbacks.length) {\n          self.callbacks.forEach(function (callback) {\n            if (typeof callback === \"function\") {\n              callback(error || undefined, self._cache);\n            }\n          });\n        }\n        self.requestInProgress = false;\n        self.callbacks = [];\n      });\n\n      // Error handler\n      result.on('error', function (error) {\n        self.callbacks.forEach(function (callback) {\n          if (typeof callback === \"function\") {\n            callback(error, undefined);\n          }\n        });\n        self.requestInProgress = false;\n        self.callbacks = [];\n      });\n    }).end();\n    return self;\n  };\n};\n\n// Only export if this is not called within Meteor\nif (typeof Meteor === 'undefined') {\n  exports.googlefonts = googlefonts;\n}","map":{"version":3,"names":["https","Meteor","require","Npm","endOfLine","EOL","instance","googlefonts","apiKey","options","singleton","self","_buffer","_cache","_lastFetch","requestInProgress","callbacks","cacheLifeTime","fetch","callback","now","Date","undefined","push","host","path","request","result","setEncoding","on","chunk","parsed","JSON","parse","error","errorBuffer","errors","forEach","message","reason","Error","length","end","exports"],"sources":["D:/websitepracticereact/node_modules/googlefonts/lib/googlefonts.js"],"sourcesContent":["// Require NPM modules in Node AND Meteor style!\nvar https = typeof Meteor === 'undefined' ? require('https') : Npm.require('https');\nvar endOfLine = (typeof Meteor === 'undefined' ? require('os') : Npm.require('os')).EOL;\n\nvar instance = false; // Holds the singleton instance\n\n// Wrapper for singleton\ngooglefonts = function(apiKey, options) {\n  instance = instance || new singleton(apiKey, options);\n  return instance;\n}\n\n// To prevent concurrent requests to the Google API we make use of a singleton.\n// There will only be one instance which handled concurrent requests internally.\nvar singleton = function(apiKey, options) {\n  \n  self = this;\n  \n  self.options = options || {};\n  \n  self.apiKey = apiKey; // Holds the API key, may it be browser or server\n  \n  self._buffer; // Buffer for API response\n  self._cache = false; // Cache for API response\n  self._lastFetch = false; // Timestamp when data was last fetched from googleapis.com\n  self.requestInProgress = false; // Will be true when API is currently queried\n  \n  // Holds all callbacks to fire when API response completes. So why is this an\n  // array? Becuase we prevent concurrent requests. In case a fetch is called\n  // while alredy an API reqeusts is running, we simply collect the callbacks\n  // and fire them all together when the first reqeusts has finished.\n  self.callbacks = [];\n  \n  // If nothing else specified, we cache API results for 1 hour\n  self.options.cacheLifeTime = self.options.cacheLifeTime || 3600;\n  \n  // Fetch API result, save it to buffer + cache and call given callbacks\n  self.fetch = function(callback) {\n    \n    // Check if we serve from cache or request the API\n    var now = new Date() / 1000;\n    if (self._cache && now - self._lastFetch < self.options.cacheLifeTime) {\n      callback(undefined,self._cache);\n      return self;\n    }\n    \n    // If a new callback was given, add it to the list of callbacks\n    if (typeof callback === \"function\") {\n      self.callbacks.push(callback);\n    }\n    \n    // If there already is a requests running, just return. The callback will be\n    // called later\n    if (self.requestInProgress === true) {\n      return self;\n    }\n    \n    self.requestInProgress = true;\n    \n    var options = {\n      host: 'www.googleapis.com',\n      path: '/webfonts/v1/webfonts?key=' + self.apiKey\n    };\n    \n    self._buffer = \"\";\n    \n    var request = https.request(options, function(result) {\n      result.setEncoding('utf8');\n      \n      // Writing incoming chunks to internal buffer\n      result.on('data', function (chunk) {\n        self._buffer += chunk;\n      });\n      \n      // Parse buffer into object, save into cache and call all callbacks\n      result.on('end', function () {\n        \n        var parsed = JSON.parse(self._buffer);\n        \n        // Google returned an error\n        if (typeof parsed.error != \"undefined\") {\n          var errorBuffer = options.host + \" returned errors:\";\n          parsed.error.errors.forEach(function(error) {\n            errorBuffer += endOfLine + \"  \" + error.message + \": \" + error.reason;\n          });\n          var error = new Error(errorBuffer);\n        }\n        \n        self._lastFetch = new Date() / 1000;\n        self._cache = parsed;\n        self.requestInProgress = false;\n        \n        //We have callbacks to fire\n        if (self.callbacks.length) {\n          self.callbacks.forEach(function(callback) {\n            if (typeof callback === \"function\") {\n              callback(error || undefined, self._cache);\n            }\n          });\n        }\n        self.requestInProgress = false;\n        self.callbacks = [];\n      });\n      \n      // Error handler\n      result.on('error', function (error) {\n        self.callbacks.forEach(function(callback) {\n          if (typeof callback === \"function\") {\n            callback(error, undefined);\n          }\n        });\n        self.requestInProgress = false;\n        self.callbacks = [];\n      });\n      \n    }).end();\n    return self;\n  }\n};\n\n// Only export if this is not called within Meteor\nif (typeof Meteor === 'undefined') {\n  exports.googlefonts = googlefonts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}